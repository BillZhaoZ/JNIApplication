# JNIApplication

JNI开发的简单案例（文字设置、吐司调用、加密解密显示）

AS下，NDK的集成；


一. JNI介绍

1. JNI引入

       JNI概念 : Java本地接口,  Java Native Interface , 它是一个  协议 , 该协议用来沟通Java代码和外部的本地C/C++代码, 通过该协议 Java代码可以调用外部的本地代码, 外部的C/C++ 代码可以调用Java代码;

为什么需要JNI呢?

   Java是一种平台无关的语言，通过不同操作系统下具有相同功能的JVM实现一次编译，可以到处运行。也正是因为JVM，使得Java程序运行的效率相对于C/C++等本地语言较低，而且不能像C/C++一样直接操作底层硬件。因为C/C++本地语言编译程序是直接被操作系统运行，而不需要类似Java的虚拟机。

　　所以如果Android app需要操作底层硬件，或要求应用的运行效率，安全性，就可以使用JNI来实现java和本地C/C++语言之间的相互调用。

C和Java的侧重 :

    --  C语言 : C语言中最重要的是 函数 function;

    --  Java语言 : Java中最重要的是 JVM, class类, 以及class中的方法;

C与Java如何交流 :

    --  JNI规范 : C语言与Java语言交流需要一个适配器, 中间件, 即 JNI, JNI提供了一种规范;
    --  C语言中调用Java方法 : 可以让我们在C代码中找到Java代码class中的方法, 并且调用该方法;
    --  Java语言中调用C语言方法 : 同时也可以在Java代码中, 将一个C语言的方法映射到Java的某个方法上;
    --  JNI桥梁作用 : JNI提供了一个桥梁, 打通了C语言和Java语言之间的障碍;

JNI中的一些概念 :

    --  native : Java语言中修饰本地方法的修饰符, 被该修饰符修饰的方法没有方法体;
    --  Native方法 : 在Java语言中被native关键字修饰的方法是Native方法;
    --  JNI层 : Java声明Native方法的部分;
    --  JNI函数 : JNIEnv提供的函数, 这些函数在jni.h中进行定义;
    --  JNI方法 : Native方法对应的JNI层实现的 C/C++方法, 即在jni目录中实现的那些C语言代码;


二、AS下JNI的集成和开发


三、.h文件的生成

    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class com_myjni_bill_myjnidemo_JniTest */

    #ifndef _Included_com_myjni_bill_myjnidemo_JniTest
    #define _Included_com_myjni_bill_myjnidemo_JniTest
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     com_myjni_bill_myjnidemo_JniTest
     * Method:    javaCallC
     * Signature: (Ljava/lang/String;)Ljava/lang/String;
     */
    JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_javaCallC
            (JNIEnv *, jobject, jstring);

    /*
     * Class:     com_myjni_bill_myjnidemo_JniTest
     * Method:    helloFromC
     * Signature: ()Ljava/lang/String;
     */
    JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_helloFromC
            (JNIEnv *, jobject);


    /*
     * Class:     com_myjni_bill_myjnidemo_JniTest
     * Method:    getStringFormC
     * Signature: ()Ljava/lang/String;
     */
    JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_getStringFormC
            (JNIEnv *, jclass);

    /*
     * Class:     com_myjni_bill_myjnidemo_JniTest
     * Method:    getKeyValue
     * Signature: ()[B
     */
    JNIEXPORT jbyteArray JNICALL Java_com_myjni_bill_myjnidemo_JniTest_getKeyValue
            (JNIEnv *, jclass);

    /*
     * Class:     com_myjni_bill_myjnidemo_JniTest
     * Method:    getIv
     * Signature: ()[B
     */
    JNIEXPORT jbyteArray JNICALL Java_com_myjni_bill_myjnidemo_JniTest_getIv
            (JNIEnv *, jclass);

    #ifdef __cplusplus
    }
    #endif
    #endif

四、Android.mk文件

     LOCAL_PATH:= $(call my-dir)

     include $(CLEAR_VARS)

     LOCAL_MODULE := HelloNDK

     LOCAL_SRC_FILES := HelloNDK.c

     include $(BUILD_SHARED_LIBRARY)

五、.c文件的编写

     #include <stdio.h>
     #include <string.h>
     #include "com_myjni_bill_myjnidemo_JniTest.h"

     /**
      * 字符串转换 拼接
      */
     JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_javaCallC
             (JNIEnv *env, jobject object, jstring string) {

         //将java的字符串转化为c的字符串
         const char *str = (*env)->GetStringUTFChars(env, string, 0);
         char buffer[512];

         //将str赋值到buffer
         strlcpy(buffer, "jni => javaCallC方法调用: ", sizeof buffer);

         //字符串拼接
         strlcat(buffer, str, sizeof buffer);

         return (*env)->NewStringUTF(env, buffer);
     }

     /**
      * 返回字符串
      */
     JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_helloFromC
             (JNIEnv *env, jobject jobject1) {

         return (*env)->NewStringUTF(env, "hello world from c: 来自C语言的问候！！");
     }


     JNIEXPORT jstring JNICALL Java_com_myjni_bill_myjnidemo_JniTest_getStringFormC
             (JNIEnv *env, jobject obj) {
         return (*env)->NewStringUTF(env, "这里是来自c的string");

     }

     const char keyValue[] = {
             21, 25, 21, -45, 25, 98, -55, -45, 10, 35, -45, 35,
             26, -5, 25, -65, -78, -99, 85, 45, -5, 10, -0, 11,
             -35, -48, -98, 65, -32, 14, -67, 25, 36, -56, -45, -5,
             12, 15, 35, -15, 25, -14, 62, -25, 33, -45, 55, 12, -8
     };

     const char iv[] = {    //16 bit
             -33, 32, -25, 25, 35, -27, 55, -12, -15, 32,
             23, 45, -26, 32, 5, 16
     };


     jbyteArray Java_com_myjni_bill_myjnidemo_JniTest_getKeyValue(JNIEnv *env, jobject obj) {

         jbyteArray kvArray = (*env)->NewByteArray(env, sizeof(keyValue));
         jbyte *bytes = (*env)->GetByteArrayElements(env, kvArray, 0);

         int i;
         for (i = 0; i < sizeof(keyValue); i++) {
             bytes[i] = (jbyte) keyValue[i];
         }

         (*env)->SetByteArrayRegion(env, kvArray, 0, sizeof(keyValue), bytes);
         (*env)->ReleaseByteArrayElements(env, kvArray, bytes, 0);

         return kvArray;
     }


     jbyteArray Java_com_myjni_bill_myjnidemo_JniTest_getIv(JNIEnv *env, jobject obj) {

         jbyteArray ivArray = (*env)->NewByteArray(env, sizeof(iv));
         jbyte *bytes = (*env)->GetByteArrayElements(env, ivArray, 0);

         int i;
         for (i = 0; i < sizeof(iv); i++) {
             bytes[i] = (jbyte) iv[i];
         }

         (*env)->SetByteArrayRegion(env, ivArray, 0, sizeof(iv), bytes);
         (*env)->ReleaseByteArrayElements(env, ivArray, bytes, 0);

         return ivArray;
     }

 六、build.gradle编写

     apply plugin: 'com.android.application'

     android {
         compileSdkVersion 23
         buildToolsVersion "23.0.2"

         defaultConfig {
             applicationId "com.myjni.bill.myjnidemo"
             minSdkVersion 17
             targetSdkVersion 23
             versionCode 1
             versionName "1.0"
             testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

             // 加载NDK项目
             ndk {
                 moduleName "HelloNDK"
                 ldLibs "log", "z", "m"    //添加依赖库文件，因为有log打印等
             }
         }

         buildTypes {
             release {
                 minifyEnabled false
                 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
             }
         }

         // 配置so文件路径  AS默认路径
         sourceSets {
             main {
                 jniLibs.srcDirs "src/main/jniLibs"
             }
         }

     }

     dependencies {
         compile fileTree(dir: 'libs', include: ['*.jar'])
         androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
             exclude group: 'com.android.support', module: 'support-annotations'
         })

         compile 'com.android.support:appcompat-v7:23.1.1'
         testCompile 'junit:junit:4.12'
     }


七、JNITest编写

    /**
     * 加载类库和C代码
     * Created by Bill on 2017/3/15.
     */
    public class JniTest {

        public static native String javaCallC(String str);

        public static native String helloFromC();

        /**
         * 以下为加密解密  部分
         *
         * @return
         */
        public static native String getStringFormC();

        public static native byte[] getKeyValue();

        public static native byte[] getIv();

        private static byte[] keyValue;
        private static byte[] iv;

        private static SecretKey key;
        private static AlgorithmParameterSpec paramSpec;
        private static Cipher ecipher;

        static {

            System.loadLibrary("HelloNDK");  //defaultConfig.ndk.moduleName

            keyValue = getKeyValue();
            iv = getIv();

            if (null != keyValue && null != iv) {
                KeyGenerator kgen;

                try {
                    kgen = KeyGenerator.getInstance("AES");
                    SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "Crypto");
                    random.setSeed(keyValue);
                    kgen.init(128, random);
                    key = kgen.generateKey();
                    paramSpec = new IvParameterSpec(iv);
                    ecipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

                } catch (NoSuchAlgorithmException e) {
                } catch (NoSuchPaddingException e) {
                } catch (NoSuchProviderException e) {
                    e.printStackTrace();
                }
            }

        }

        /**
         * 加密
         **/
        public static String encode(String msg) {
            String str = "";
            try {
                //用密钥和一组算法参数初始化此 cipher
                ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
                //加密并转换成16进制字符串
                str = asHex(ecipher.doFinal(msg.getBytes()));
            } catch (BadPaddingException e) {
            } catch (InvalidKeyException e) {
            } catch (InvalidAlgorithmParameterException e) {
            } catch (IllegalBlockSizeException e) {
            }

            return str;
        }

        /**
         * 解密
         **/
        public static String decode(String value) {
            try {
                ecipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
                return new String(ecipher.doFinal(asBin(value)));
            } catch (BadPaddingException e) {
            } catch (InvalidKeyException e) {
            } catch (InvalidAlgorithmParameterException e) {
            } catch (IllegalBlockSizeException e) {
            }
            return "";
        }

        /**
         * 转16进制
         **/
        private static String asHex(byte buf[]) {
            StringBuffer strbuf = new StringBuffer(buf.length * 2);
            int i;
            for (i = 0; i < buf.length; i++) {
                if (((int) buf[i] & 0xff) < 0x10)//小于十前面补零
                    strbuf.append("0");
                strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
            }
            return strbuf.toString();
        }

        /**
         * 转2进制
         **/
        private static byte[] asBin(String src) {
            if (src.length() < 1)
                return null;
            byte[] encrypted = new byte[src.length() / 2];
            for (int i = 0; i < src.length() / 2; i++) {
                int high = Integer.parseInt(src.substring(i * 2, i * 2 + 1), 16);//取高位字节
                int low = Integer.parseInt(src.substring(i * 2 + 1, i * 2 + 2), 16);//取低位字节
                encrypted[i] = (byte) (high * 16 + low);
            }
            return encrypted;
        }
    }


八、MainActivity编写

     /**
      * 主界面
      */
     public class MainActivity extends AppCompatActivity {

         @Override
         protected void onCreate(Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
             setContentView(R.layout.activity_main);

             // 设置标题
             setTitle("JNI开发实例");

             TextView view = (TextView) findViewById(R.id.tv_jni);
             Button btn = (Button) findViewById(R.id.btn_model);

             // 调用C方法
             String s = JniTest.javaCallC("大力牛魔王！");
             final String helloFromC = JniTest.helloFromC();
             view.setText(s);

             // 吐司
             Toast(btn, helloFromC);

             TextView textView = (TextView) findViewById(R.id.ndk_text);
             String str = JniTest.getStringFormC();

             // 加密部分
             encrypt(textView, str);
         }

         /**
          * 吐司
          *
          * @param btn
          * @param helloFromC
          */
         private void Toast(Button btn, final String helloFromC) {
             btn.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View v) {
                     Toast.makeText(getApplicationContext(), helloFromC, Toast.LENGTH_SHORT).show();
                 }
             });
         }

         /**
          * 加密
          *
          * @param textView
          * @param str
          */
         private void encrypt(TextView textView, String str) {
             String ming = "13550110110";
             String encrypmi = JniTest.encode(ming);
             String decrypmi = JniTest.decode(encrypmi);

             textView.setText("来自c的string是:" + str + "\n加密前：" + ming + "\n加密后：" + encrypmi + "\n解密后：" + decrypmi);
         }

     }
